generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(uuid())
  pokePokeId      String           @unique
  name            String
  passwordHash    String
  role            String           @default("USER")
  isBlacklisted   Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  // Relations
  cardCollection  CardCollection?
  sentTradeOffers      TradeOffer[]     @relation("Sender")
  receivedTradeOffers  TradeOffer[]     @relation("Receiver")
  sentMessages         Message[]        @relation("Sender")
}

model CardCollection {
  id        String   @id @default(uuid())
  userId    String   @unique 
                   // Given the requirements, likely we store simplified data or relations.
                   // "CardCollectionService... コレクション選択ロジック" implies complexity. 
                   // However, usually detailed cards are stored as separate relations or JSON. 
                   // Let's use a simplified approach or a relation to a CardItem model if we want to query easily.
                   // But for now, let's assume we might need a dedicated table for cards in collection to query "users who have card X".
                   
  // Actually, to implement "search logic" (A6) effectively, we likely need to query "who has card X".
  // Storing as JSON makes that harder/slower in SQLite/MySQL without native JSON ops or robust indexing.
  // Let's make a separate model for items in collection.
  items     CollectionItem[]

  user      User     @relation(fields: [userId], references: [id])
}

model CollectionItem {
  id               String         @id @default(uuid())
  collectionId     String
  cardId           String
  quantity         Int            @default(1)
  
  collection       CardCollection @relation(fields: [collectionId], references: [id])
  
  // For TradeOffer relations if we want to link specific instances, 
  // but usually trade offers just reference card IDs and verification checks ownership.
  // We'll link TradeOfferCard to CardId (string) generally.

  @@unique([collectionId, cardId])
}

model TradeOffer {
  id          String           @id @default(uuid())
  senderId    String
  receiverId  String
  status      String           // PENDING, ACCEPTED, REJECTED, CANCELED
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  sender      User             @relation("Sender", fields: [senderId], references: [id])
  receiver    User             @relation("Receiver", fields: [receiverId], references: [id])
  
  details     TradeOfferCard[]
  messages    Message[]
}

model TradeOfferCard {
  id            String     @id @default(uuid())
  tradeOfferId  String
  cardId        String
  type          String     // WANTED (sender wants), GIVEN (sender gives)
  quantity      Int        @default(1)
  
  tradeOffer    TradeOffer @relation(fields: [tradeOfferId], references: [id])
}

model Message {
  id            String     @id @default(uuid())
  tradeOfferId  String
  senderId      String
  content       String
  createdAt     DateTime   @default(now())
  
  tradeOffer    TradeOffer @relation(fields: [tradeOfferId], references: [id])
  sender        User       @relation("Sender", fields: [senderId], references: [id])
}
